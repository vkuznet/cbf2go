package cbf

import (
	"bufio"
	"bytes"
	"compress/zlib"
	"encoding/binary"
	"errors"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"io"
	"log"
	"math"
	"os"
	"strconv"
	"strings"
)

///////////////////////////////////////////////////////////////////////////////
// MAIN API
///////////////////////////////////////////////////////////////////////////////

func ReadCBF(path string) ([]int32, int, int, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, 0, 0, err
	}

	header, bin, err := splitHeaderBinary(data)
	if err != nil {
		return nil, 0, 0, err
	}

	w, h := parseDimensions(header)
	enc := detectEncoding(header)

	switch enc {
	case "CANONICAL":
		return decodeCanonical(bin, w, h)
	case "PACKED":
		return decodePacked(bin, w, h)
	case "BYTE_OFFSET":
		/*
			n := parseBinaryElementCount(header)
			if n <= 0 {
				return nil, 0, 0, fmt.Errorf("missing X-Binary-Number-of-Elements")
			}
			return decodeByteOffset(bin, w, h, n)
		*/
		//return decodeByteOffset(bin, header)
		pixels, err := decByteOffsetFabio(bin, w*h)
		return pixels, w, h, err
	default:
		return nil, 0, 0, fmt.Errorf("unsupported CBF encoding: %s", enc)
	}
}

///////////////////////////////////////////////////////////////////////////////
// HEADER SPLIT / DETECTION
///////////////////////////////////////////////////////////////////////////////

func splitHeaderBinary(data []byte) (header string, binary []byte, err error) {

	// Split at form-feed (0x0C)
	parts := bytes.SplitN(data, []byte("\x0c"), 2)
	if len(parts) != 2 {
		return "", nil, errors.New("invalid CBF: missing 0x0C separator")
	}

	header = string(parts[0])
	rest := parts[1]

	// CBF binary section has ASCII headers ending with a blank line
	sep := []byte("\n\n")
	idx := bytes.Index(rest, sep)
	if idx < 0 {
		return "", nil, errors.New("invalid CBF: missing binary header terminator")
	}

	// Binary data starts AFTER the blank line
	binary = rest[idx+len(sep):]
	return header, binary, nil
}

func detectEncoding(header string) string {
	h := strings.ToUpper(header)

	switch {
	case strings.Contains(h, "PACKED") || strings.Contains(h, "CBF_PACKED"):
		return "PACKED"
	case strings.Contains(h, "CANONICAL"):
		return "CANONICAL"
	case strings.Contains(h, "X-CBF_BYTE_OFFSET"):
		return "BYTE_OFFSET"
	default:
		return "UNKNOWN"
	}
}

// /////////////////////////////////////////////////////////////////////////////
// BYTE_OFFSET DECODER (FIXED)
// /////////////////////////////////////////////////////////////////////////////
func decodeByteOffsetOrig(
	bin []byte,
	w, h int,
	numElements int,
) ([]int32, int, int, error) {

	raw, err := tryZlib(bin)
	if err != nil {
		return nil, 0, 0, err
	}

	br := bufio.NewReader(bytes.NewReader(raw))

	// --- 1. Read BYTE_OFFSET width header ---
	hdr, err := br.ReadByte()
	if err != nil {
		return nil, 0, 0, fmt.Errorf("byte_offset: cannot read width header: %w", err)
	}

	wflag := int(hdr & 0x03)
	var bwidth int
	switch wflag {
	case 0:
		bwidth = 1
	case 1:
		bwidth = 2
	case 2:
		bwidth = 4
	default:
		return nil, 0, 0, fmt.Errorf("byte_offset: invalid width flag %d", wflag)
	}

	// --- 2. Decode deltas ---
	out := make([]int32, numElements)
	prev := int32(0)
	buf := make([]byte, bwidth)

	for i := 0; i < numElements; i++ {
		if _, err := io.ReadFull(br, buf); err != nil {
			return nil, 0, 0, fmt.Errorf(
				"byte_offset truncated: decoded %d of %d pixels",
				i, numElements,
			)
		}

		var delta int32
		switch bwidth {
		case 1:
			delta = int32(int8(buf[0]))
		case 2:
			delta = int32(int16(binary.BigEndian.Uint16(buf)))
		case 4:
			delta = int32(int32(binary.BigEndian.Uint32(buf)))
		}

		prev += delta
		out[i] = prev
	}

	return out, w, h, nil
}

func decodeByteOffset(bin []byte, header string) ([]int32, int, int, error) {
	// 1) Parse dimensions
	w, h := parseDimensions(header)
	if w <= 0 || h <= 0 {
		return nil, 0, 0, fmt.Errorf("invalid dimensions")
	}

	// 2) Parse number of elements
	numElements := parseBinaryElementCount(header)
	if numElements <= 0 {
		return nil, 0, 0, fmt.Errorf("missing X-Binary-Number-Of-Elements")
	}

	// 3) Decompress zlib if needed
	raw, err := tryZlib(bin)
	if err != nil {
		return nil, 0, 0, err
	}
	br := bufio.NewReader(bytes.NewReader(raw))

	// 4) Read width header byte
	hdr, err := br.ReadByte()
	if err != nil {
		return nil, 0, 0, fmt.Errorf("byte_offset: cannot read width header: %w", err)
	}

	wflag := int(hdr & 0x03)
	var bwidth int
	switch wflag {
	case 0:
		bwidth = 1
	case 1:
		bwidth = 2
	case 2:
		bwidth = 4
	default:
		return nil, 0, 0, fmt.Errorf("byte_offset: invalid width flag %d", wflag)
	}

	// 5) Decode deltas
	out := make([]int32, numElements)
	prev := int32(0)
	buf := make([]byte, bwidth)

	for i := 0; i < numElements; i++ {
		if _, err := io.ReadFull(br, buf); err != nil {
			return nil, 0, 0, fmt.Errorf(
				"byte_offset truncated: decoded %d of %d pixels",
				i, numElements,
			)
		}

		var delta int32
		switch bwidth {
		case 1:
			delta = int32(int8(buf[0]))
		case 2:
			delta = int32(int16(binary.LittleEndian.Uint16(buf)))
		case 4:
			delta = int32(binary.LittleEndian.Uint32(buf))
		}

		prev += delta
		out[i] = prev
	}

	// 6) Reconcile dimensions
	w, h = ReconcileDimensions(out, w, h)
	return out, w, h, nil
}

///////////////////////////////////////////////////////////////////////////////
// PACKED DECODER
///////////////////////////////////////////////////////////////////////////////

func decodePacked(bin []byte, w, h int) ([]int32, int, int, error) {

	raw, _ := tryZlib(bin) // FIX: auto-detect zlib

	r := bytes.NewReader(raw)
	br := bufio.NewReader(r)

	total := w * h
	out := make([]int32, total)

	var prev int32 = 0

	for i := 0; i < total; i++ {
		delta, err := readPackedInt(br)
		if err != nil {
			return nil, 0, 0, fmt.Errorf("packed: %w", err)
		}
		prev += delta
		out[i] = prev
	}

	return out, w, h, nil
}

func readPackedInt(r *bufio.Reader) (int32, error) {
	b, err := r.ReadByte()
	if err != nil {
		return 0, err
	}

	if b&0x80 == 0 {
		return int32(int8(b)), nil // small int
	}

	length := int(b & 0x7F)
	if length == 0 {
		return 0, nil
	}

	buf := make([]byte, length)
	_, err = io.ReadFull(r, buf)
	if err != nil {
		return 0, err
	}

	// big-endian signed
	switch length {
	case 1:
		return int32(int8(buf[0])), nil
	case 2:
		return int32(int16(binary.BigEndian.Uint16(buf))), nil
	case 4:
		return int32(int32(binary.BigEndian.Uint32(buf))), nil
	default:
		return 0, fmt.Errorf("packed: unsupported %d-byte integer", length)
	}
}

///////////////////////////////////////////////////////////////////////////////
// CANONICAL DECODER
///////////////////////////////////////////////////////////////////////////////

func decodeCanonical(bin []byte, w, h int) ([]int32, int, int, error) {
	txt := string(bin)
	fields := strings.Fields(txt)

	expected := w * h
	if len(fields) < expected {
		return nil, 0, 0, fmt.Errorf("canonical: expected %d values, got %d", expected, len(fields))
	}

	out := make([]int32, expected)
	for i := 0; i < expected; i++ {
		v, err := strconv.Atoi(fields[i])
		if err != nil {
			return nil, 0, 0, err
		}
		out[i] = int32(v)
	}

	return out, w, h, nil
}

///////////////////////////////////////////////////////////////////////////////
// HELPERS
///////////////////////////////////////////////////////////////////////////////

func tryZlib(bin []byte) ([]byte, error) {
	zr, err := zlib.NewReader(bytes.NewReader(bin))
	if err != nil {
		return bin, nil // not compressed, using raw
	}
	defer zr.Close()

	raw, err := io.ReadAll(zr)
	if err != nil {
		return nil, err
	}
	return raw, nil
}

func parseBinaryElementCount(header string) int {
	for _, l := range strings.Split(header, "\n") {
		if strings.Contains(strings.ToUpper(l), "X-BINARY-NUMBER-OF-ELEMENTS") {
			v, _ := strconv.Atoi(strings.TrimSpace(strings.Split(l, ":")[1]))
			return v
		}
	}
	return 0
}

func parseDimensions(header string) (w, h int) {
	lines := strings.Split(header, "\n")

	// --- 1. Preferred: _array_structure_list.array_size ---
	var sizes []int
	for _, line := range lines {
		up := strings.ToUpper(line)
		if strings.Contains(up, "_ARRAY_STRUCTURE_LIST.ARRAY_SIZE") {
			fields := strings.Fields(line)
			if len(fields) >= 2 {
				if v, err := strconv.Atoi(fields[len(fields)-1]); err == nil {
					sizes = append(sizes, v)
				}
			}
		}
	}

	// CBF convention: fast dimension first (X), slow second (Y)
	if len(sizes) >= 2 {
		return sizes[0], sizes[1]
	}

	// --- 2. Fallback: X-BINARY-SIZE headers ---
	for _, line := range lines {
		up := strings.ToUpper(line)
		if strings.Contains(up, "X-BINARY-SIZE-FASTEST-DIMENSION") {
			w, _ = strconv.Atoi(strings.TrimSpace(strings.Split(line, ":")[1]))
		}
		if strings.Contains(up, "X-BINARY-SIZE-SECOND-DIMENSION") {
			h, _ = strconv.Atoi(strings.TrimSpace(strings.Split(line, ":")[1]))
		}
	}

	return
}

func ReconcileDimensions(pixels []int32, w, h int) (int, int) {
	n := len(pixels)

	// Prefer binary element count over header geometry
	if w > 0 && h > 0 && w*h > n {
		// header overstates size → trust element count
		if n%w == 0 {
			return w, n / w
		}
		if n%h == 0 {
			return n / h, h
		}
	}

	// Existing logic
	if w > 0 && h > 0 && w*h == n {
		return w, h
	}
	if w > 0 && n%w == 0 {
		return w, n / w
	}
	if h > 0 && n%h == 0 {
		return n / h, h
	}

	panic(fmt.Sprintf(
		"cannot reconcile dimensions: pixels=%d w=%d h=%d",
		n, w, h,
	))
}

///////////////////////////////////////////////////////////////////////////////
// CBF → PNG CONVERSION
///////////////////////////////////////////////////////////////////////////////

// WritePNG converts decoded CBF pixels into a grayscale PNG.
// It performs:
//   - dimension reconciliation
//   - robust min/max normalization
//   - safe bounds handling
func WritePNG(pixels []int32, w, h int, outPath string) error {

	// Ensure dimensions match pixel count
	log.Println("WritePNG", pixels[:10], w, h)
	//w, h = ReconcileDimensions(pixels, w, h)

	if w <= 0 || h <= 0 {
		return fmt.Errorf("invalid image dimensions: %dx%d", w, h)
	}

	img := image.NewGray(image.Rect(0, 0, w, h))

	// --- Compute min/max (robust) ---
	var minVal int32 = math.MaxInt32
	var maxVal int32 = math.MinInt32

	for _, v := range pixels {
		if v < minVal {
			minVal = v
		}
		if v > maxVal {
			maxVal = v
		}
	}

	if maxVal <= minVal {
		return fmt.Errorf("invalid intensity range: min=%d max=%d", minVal, maxVal)
	}

	scale := float64(255) / float64(maxVal-minVal)

	// --- Fill image ---
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {

			idx := y*w + x
			if idx >= len(pixels) {
				// Zero-pad if truncated
				img.SetGray(x, y, color.Gray{Y: 0})
				continue
			}

			v := pixels[idx]
			norm := (float64(v-minVal) * scale)

			if norm < 0 {
				norm = 0
			}
			if norm > 255 {
				norm = 255
			}

			img.SetGray(x, y, color.Gray{Y: uint8(norm)})
		}
	}

	// --- Write PNG ---
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()

	return png.Encode(f, img)
}

///////////////////////////////////////////////////////////////////////////////
// EXAMPLE MAIN
///////////////////////////////////////////////////////////////////////////////

func example() {
	pixels, w, h, err := ReadCBF("test_image.cbf")
	if err != nil {
		panic(err)
	}

	fmt.Println("Image:", w, "x", h)
	fmt.Println("First pixel:", pixels[0])
	//fmt.Println("Pixels:\n%+v", pixels)

	// write to PNG
	err = WritePNG(pixels, w, h, "output.png")
	if err != nil {
		panic(err)
	}

	fmt.Println("PNG written: output.png")
}

func parseElementByteWidth(header string) (int, error) {
	h := strings.ToUpper(header)

	switch {
	case strings.Contains(h, "SIGNED 8-BIT"):
		return 1, nil
	case strings.Contains(h, "SIGNED 16-BIT"):
		return 2, nil
	case strings.Contains(h, "SIGNED 32-BIT"):
		return 4, nil
	default:
		return 0, fmt.Errorf("unsupported or missing X-Binary-Element-Type")
	}
}

func decByteOffsetFabio(raw []byte, size int) ([]int32, error) {
	if len(raw) == 0 {
		return nil, fmt.Errorf("empty byte_offset stream")
	}

	out := make([]int32, size)
	r := bytes.NewReader(raw)

	// --- FIRST VALUE IS ABSOLUTE ---
	var first int8
	if err := binary.Read(r, binary.LittleEndian, &first); err != nil {
		return nil, err
	}
	out[0] = int32(first)

	i := 1
	for i < size {
		var d8 int8
		if err := binary.Read(r, binary.LittleEndian, &d8); err != nil {
			return nil, fmt.Errorf("truncated at pixel %d", i)
		}

		delta := int32(d8)

		// --- WIDTH ESCALATION ---
		if d8 == -128 {
			var d16 int16
			if err := binary.Read(r, binary.LittleEndian, &d16); err != nil {
				return nil, fmt.Errorf("truncated int16 at pixel %d", i)
			}
			delta = int32(d16)

			if d16 == -32768 {
				var d32 int32
				if err := binary.Read(r, binary.LittleEndian, &d32); err != nil {
					return nil, fmt.Errorf("truncated int32 at pixel %d", i)
				}
				delta = d32
			}
		}

		out[i] = out[i-1] + delta
		i++
	}

	return out, nil
}
